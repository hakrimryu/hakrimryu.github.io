/*!
 * Chirpy v6.5.5 | Â© 2019 Cotes Chung | MIT Licensed | https://github.com/cotes2020/jekyll-theme-chirpy/
 */

(function () {
  'use strict';

  /**
   * Reference: https://bootsnipp.com/snippets/featured/link-to-top-page
   */

  function back2top() {
    const btn = document.getElementById('back-to-top');
    window.addEventListener('scroll', () => {
      if (window.scrollY > 50) {
        btn.classList.add('show');
      } else {
        btn.classList.remove('show');
      }
    });
    btn.addEventListener('click', () => {
      window.scrollTo({
        top: 0
      });
    });
  }

  /**
   * Initial Bootstrap Tooltip.
   */
  function loadTooptip() {
    const tooltipTriggerList = document.querySelectorAll('[data-bs-toggle="tooltip"]');
    [...tooltipTriggerList].map(tooltipTriggerEl => new bootstrap.Tooltip(tooltipTriggerEl));
  }

  function basic() {
    back2top();
    loadTooptip();
  }

  /**
   * Add listener for theme mode toggle
   */
  const toggle = document.getElementById('mode-toggle');
  function modeWatcher() {
    if (!toggle) {
      return;
    }
    toggle.addEventListener('click', () => {
      modeToggle.flipMode();
    });
  }

  function _toPrimitive(t, r) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
  }
  function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }

  /**
   * Expand or close the sidebar in mobile screens.
   */

  const ATTR_DISPLAY = 'sidebar-display';
  class SidebarUtil {
    static toggle() {
      if (SidebarUtil.isExpanded === false) {
        document.body.setAttribute(ATTR_DISPLAY, '');
      } else {
        document.body.removeAttribute(ATTR_DISPLAY);
      }
      SidebarUtil.isExpanded = !SidebarUtil.isExpanded;
    }
  }
  _defineProperty(SidebarUtil, "isExpanded", false);
  function sidebarExpand() {
    document.getElementById('sidebar-trigger').addEventListener('click', SidebarUtil.toggle);
    document.getElementById('mask').addEventListener('click', SidebarUtil.toggle);
  }

  function initSidebar() {
    modeWatcher();
    sidebarExpand();
  }

  /**
   * This script make #search-result-wrapper switch to unloaded or shown automatically.
   */

  const btnSbTrigger = document.getElementById('sidebar-trigger');
  const btnSearchTrigger = document.getElementById('search-trigger');
  const btnCancel = document.getElementById('search-cancel');
  const content = document.querySelectorAll('#main-wrapper>.container>.row');
  const topbarTitle = document.getElementById('topbar-title');
  const search = document.getElementById('search');
  const resultWrapper = document.getElementById('search-result-wrapper');
  const results = document.getElementById('search-results');
  const input = document.getElementById('search-input');
  const hints = document.getElementById('search-hints');

  // CSS class names
  const LOADED = 'loaded';
  const UNLOADED = 'unloaded';
  const FOCUS = 'input-focus';
  const FLEX = 'd-flex';

  /* Actions in mobile screens (Sidebar hidden) */
  class MobileSearchBar {
    static on() {
      btnSbTrigger.classList.add(UNLOADED);
      topbarTitle.classList.add(UNLOADED);
      btnSearchTrigger.classList.add(UNLOADED);
      search.classList.add(FLEX);
      btnCancel.classList.add(LOADED);
    }
    static off() {
      btnCancel.classList.remove(LOADED);
      search.classList.remove(FLEX);
      btnSbTrigger.classList.remove(UNLOADED);
      topbarTitle.classList.remove(UNLOADED);
      btnSearchTrigger.classList.remove(UNLOADED);
    }
  }
  class ResultSwitch {
    static on() {
      if (!this.resultVisible) {
        resultWrapper.classList.remove(UNLOADED);
        content.forEach(el => {
          el.classList.add(UNLOADED);
        });
        this.resultVisible = true;
      }
    }
    static off() {
      if (this.resultVisible) {
        results.innerHTML = '';
        if (hints.classList.contains(UNLOADED)) {
          hints.classList.remove(UNLOADED);
        }
        resultWrapper.classList.add(UNLOADED);
        content.forEach(el => {
          el.classList.remove(UNLOADED);
        });
        input.textContent = '';
        this.resultVisible = false;
      }
    }
  }
  _defineProperty(ResultSwitch, "resultVisible", false);
  function isMobileView() {
    return btnCancel.classList.contains(LOADED);
  }
  function displaySearch() {
    btnSearchTrigger.addEventListener('click', () => {
      MobileSearchBar.on();
      ResultSwitch.on();
      input.focus();
    });
    btnCancel.addEventListener('click', () => {
      MobileSearchBar.off();
      ResultSwitch.off();
    });
    input.addEventListener('focus', () => {
      search.classList.add(FOCUS);
    });
    input.addEventListener('focusout', () => {
      search.classList.remove(FOCUS);
    });
    input.addEventListener('input', () => {
      if (input.value === '') {
        if (isMobileView()) {
          hints.classList.remove(UNLOADED);
        } else {
          ResultSwitch.off();
        }
      } else {
        ResultSwitch.on();
        if (isMobileView()) {
          hints.classList.add(UNLOADED);
        }
      }
    });
  }

  function initTopbar() {
    displaySearch();
  }

  /**
   * Tab 'Categories' expand/close effect.
   */
  document.getElementsByClassName('collapse');

  /**
   * Clipboard functions
   *
   * Dependencies:
   *   - popper.js (https://github.com/popperjs/popper-core)
   *   - clipboard.js (https://github.com/zenorocha/clipboard.js)
   */

  const clipboardSelector = '.code-header>button';
  const ICON_DEFAULT = 'far fa-clipboard';
  const ICON_SUCCESS = 'fas fa-check';
  const ATTR_TIMEOUT = 'timeout';
  const ATTR_TITLE_SUCCEED = 'data-title-succeed';
  const ATTR_TITLE_ORIGIN = 'data-bs-original-title';
  const TIMEOUT = 2000; // in milliseconds

  function isLocked(node) {
    if (node.hasAttribute(ATTR_TIMEOUT)) {
      let timeout = node.getAttribute(ATTR_TIMEOUT);
      if (Number(timeout) > Date.now()) {
        return true;
      }
    }
    return false;
  }
  function lock(node) {
    node.setAttribute(ATTR_TIMEOUT, Date.now() + TIMEOUT);
  }
  function unlock(node) {
    node.removeAttribute(ATTR_TIMEOUT);
  }
  function showTooltip(btn) {
    const succeedTitle = btn.getAttribute(ATTR_TITLE_SUCCEED);
    btn.setAttribute(ATTR_TITLE_ORIGIN, succeedTitle);
    bootstrap.Tooltip.getInstance(btn).show();
  }
  function hideTooltip(btn) {
    bootstrap.Tooltip.getInstance(btn).hide();
    btn.removeAttribute(ATTR_TITLE_ORIGIN);
  }
  function setSuccessIcon(btn) {
    const icon = btn.children[0];
    icon.setAttribute('class', ICON_SUCCESS);
  }
  function resumeIcon(btn) {
    const icon = btn.children[0];
    icon.setAttribute('class', ICON_DEFAULT);
  }
  function initClipboard() {
    const clipboardList = document.querySelectorAll(clipboardSelector);
    if (clipboardList.length === 0) {
      return;
    }

    // Initial the clipboard.js object
    const clipboard = new ClipboardJS(clipboardSelector, {
      target: trigger => {
        const codeBlock = trigger.parentNode.nextElementSibling;
        return codeBlock.querySelector('code .rouge-code');
      }
    });
    [...clipboardList].map(elem => new bootstrap.Tooltip(elem, {
      placement: 'left'
    }));
    clipboard.on('success', e => {
      const trigger = e.trigger;
      e.clearSelection();
      if (isLocked(trigger)) {
        return;
      }
      setSuccessIcon(trigger);
      showTooltip(trigger);
      lock(trigger);
      setTimeout(() => {
        hideTooltip(trigger);
        resumeIcon(trigger);
        unlock(trigger);
      }, TIMEOUT);
    });

    /* --- Post link sharing --- */

    const btnCopyLink = document.getElementById('copy-link');
    btnCopyLink.addEventListener('click', e => {
      const target = e.target;
      if (isLocked(target)) {
        return;
      }

      // Copy URL to clipboard
      navigator.clipboard.writeText(window.location.href).then(() => {
        const defaultTitle = target.getAttribute(ATTR_TITLE_ORIGIN);
        const succeedTitle = target.getAttribute(ATTR_TITLE_SUCCEED);

        // Switch tooltip title
        target.setAttribute(ATTR_TITLE_ORIGIN, succeedTitle);
        bootstrap.Tooltip.getInstance(target).show();
        lock(target);
        setTimeout(() => {
          target.setAttribute(ATTR_TITLE_ORIGIN, defaultTitle);
          unlock(target);
        }, TIMEOUT);
      });
    });
    btnCopyLink.addEventListener('mouseleave', e => {
      bootstrap.Tooltip.getInstance(e.target).hide();
    });
  }

  /**
   * Setting up image lazy loading and LQIP switching
   */

  const ATTR_DATA_SRC = 'data-src';
  const ATTR_DATA_LQIP = 'data-lqip';
  const cover = {
    SHIMMER: 'shimmer',
    BLUR: 'blur'
  };
  function removeCover(clzss) {
    this.parentElement.classList.remove(clzss);
  }
  function handleImage() {
    if (!this.complete) {
      return;
    }
    if (this.hasAttribute(ATTR_DATA_LQIP)) {
      removeCover.call(this, cover.BLUR);
    } else {
      removeCover.call(this, cover.SHIMMER);
    }
  }

  /**
   * Switches the LQIP with the real image URL.
   */
  function switchLQIP() {
    const src = this.getAttribute(ATTR_DATA_SRC);
    this.setAttribute('src', encodeURI(src));
    this.removeAttribute(ATTR_DATA_SRC);
  }
  function loadImg() {
    const images = document.querySelectorAll('article img');
    if (images.length === 0) {
      return;
    }
    images.forEach(img => {
      img.addEventListener('load', handleImage);
    });

    // Images loaded from the browser cache do not trigger the 'load' event
    document.querySelectorAll('article img[loading="lazy"]').forEach(img => {
      if (img.complete) {
        removeCover.call(img, cover.SHIMMER);
      }
    });

    // LQIPs set by the data URI or WebP will not trigger the 'load' event,
    // so manually convert the URI to the URL of a high-resolution image.
    const lqips = document.querySelectorAll("article img[".concat(ATTR_DATA_LQIP, "=\"true\"]"));
    if (lqips.length) {
      lqips.forEach(lqip => {
        switchLQIP.call(lqip);
      });
    }
  }

  /**
   * Set up image popup
   *
   * Dependencies: https://github.com/biati-digital/glightbox
   */

  const IMG_CLASS = 'popup';
  function imgPopup() {
    if (document.getElementsByClassName(IMG_CLASS).length === 0) {
      return;
    }
    GLightbox({
      selector: ".".concat(IMG_CLASS)
    });
  }

  /**
   * Update month/day to locale datetime
   *
   * Requirement: <https://github.com/iamkun/dayjs>
   */

  /* A tool for locale datetime */
  class LocaleHelper {
    static get attrTimestamp() {
      return 'data-ts';
    }
    static get attrDateFormat() {
      return 'data-df';
    }
    static get locale() {
      return document.documentElement.getAttribute('lang').substring(0, 2);
    }
    static getTimestamp(elem) {
      return Number(elem.getAttribute(this.attrTimestamp)); // unix timestamp
    }
    static getDateFormat(elem) {
      return elem.getAttribute(this.attrDateFormat);
    }
  }
  function initLocaleDatetime() {
    dayjs.locale(LocaleHelper.locale);
    dayjs.extend(window.dayjs_plugin_localizedFormat);
    document.querySelectorAll("[".concat(LocaleHelper.attrTimestamp, "]")).forEach(elem => {
      const date = dayjs.unix(LocaleHelper.getTimestamp(elem));
      const text = date.format(LocaleHelper.getDateFormat(elem));
      elem.textContent = text;
      elem.removeAttribute(LocaleHelper.attrTimestamp);
      elem.removeAttribute(LocaleHelper.attrDateFormat);

      // setup tooltips
      if (elem.hasAttribute('data-bs-toggle') && elem.getAttribute('data-bs-toggle') === 'tooltip') {
        // see: https://day.js.org/docs/en/display/format#list-of-localized-formats
        const tooltipText = date.format('llll');
        elem.setAttribute('data-bs-title', tooltipText);
      }
    });
  }

  function toc() {
    if (document.querySelector('main h2, main h3')) {
      // see: https://github.com/tscanlin/tocbot#usage
      tocbot.init({
        tocSelector: '#toc',
        contentSelector: '.content',
        ignoreSelector: '[data-toc-skip]',
        headingSelector: 'h2, h3, h4',
        orderedList: false,
        scrollSmooth: false
      });
    }
  }

  initSidebar();
  initTopbar();
  loadImg();
  imgPopup();
  initLocaleDatetime();
  initClipboard();
  toc();
  basic();

})();
//# sourceMappingURL=post.min.js.map
